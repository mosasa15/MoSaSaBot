var rolethinker = {
    /** @param {Creep} creep **/
    //-------------------------------------------------------------------------------------
    run: function(creep) {
        // creep.memory.dontPullMe = true; 
        const labs = creep.room.lab;
        const storage = creep.room.storage;
        const terminal = creep.room.terminal;
        
        if (!labs || labs.length === 0) return;

        // Dynamic Lab Configuration Check
        // Ideally, Lab.js defines what resources are needed.
        // We can access this via Memory.rooms[roomName].labs.targetIndex
        // But here we need to know the 'resourceTypes' array to iterate.
        // Instead of hardcoding, let's look at what the labs actually need.
        
        // Strategy:
        // 1. Check if any lab needs energy (Energy filling is priority).
        // 2. Check if input labs need resources (Input filling).
        
        const notFullEnergyLabs = labs.filter(lab => lab.store[RESOURCE_ENERGY] < 2000); 
        
        if ( notFullEnergyLabs.length > 0 ){
            // Priority: Fill Energy
            if(creep.store.getFreeCapacity(RESOURCE_ENERGY) === 0 && creep.store[RESOURCE_ENERGY] === 0 ){
                // Empty unrelated resources
                for(const resourceType in creep.store) {
                    if(creep.transfer(terminal, resourceType) === ERR_NOT_IN_RANGE) {
                        creep.moveTo(terminal, {visualizePathStyle: {stroke: '#ffffff'}});  
                    }
                }
            }
            if(creep.store[RESOURCE_ENERGY] === 0) {
                if(creep.withdraw(storage, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {
                    creep.moveTo(storage, {visualizePathStyle: {stroke: '#ffaa00'}});
                }
            } else {
                var closestTarget = findClosestTarget(creep, notFullEnergyLabs);
                if (creep.transfer(closestTarget, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {
                    creep.moveTo(closestTarget, {visualizePathStyle: {stroke: '#ffffff'}})
                }
            }
        } else {
            // Priority: Fill Minerals
            // Use Memory to determine which minerals are needed.
            // Assuming Lab.js sets Memory.rooms[roomName].labs.targetIndex etc.
            // But Lab.js logic is complex. 
            // Simplified Logic: Check Memory for active Lab Tasks?
            // Or look at Lab Memory directly?
            
            const labMemory = Memory.rooms[creep.room.name].labs;
            if (!labMemory || !labMemory.inLabs) return;
            
            // Check input labs (usually the first 2)
            const inLabIds = labMemory.inLabs;
            const requiredAmount = 3000; // Threshold
            
            let worked = false;
            
            // We can iterate over tasks generated by Lab.js (withdraw tasks)
            const tasksList = Memory.rooms[creep.room.name].tasks;
            const withdrawTask = tasksList.find(t => t.type === 'withdraw' && inLabIds.includes(t.labId));
            
            if (withdrawTask) {
                // Execute the withdraw task: Get resource from Terminal -> Put in Lab
                const lab = Game.getObjectById(withdrawTask.labId);
                const resourceType = withdrawTask.resourceType;
                const amount = withdrawTask.amount;
                
                if (lab) {
                    if (creep.store[resourceType] === 0) {
                        // Withdraw from Terminal
                        // Ensure we don't have other resources
                         if (creep.store.getUsedCapacity() > 0 && !creep.store[resourceType]) {
                             creep.transfer(terminal, Object.keys(creep.store)[0]);
                         }
                         
                         const withdrawAmount = Math.min(amount, creep.store.getCapacity());
                         if (creep.withdraw(terminal, resourceType) === ERR_NOT_IN_RANGE) {
                             creep.moveTo(terminal, {visualizePathStyle: {stroke: '#ffffff'}});
                         }
                    } else {
                        // Transfer to Lab
                        if (creep.transfer(lab, resourceType) === ERR_NOT_IN_RANGE) {
                            creep.moveTo(lab, {visualizePathStyle: {stroke: '#ffffff'}});
                        }
                    }
                    worked = true;
                }
            }
            
            if (!worked) {
                // Idle or empty self
                 if(creep.store.getUsedCapacity() > 0) {
                     // Empty to storage or terminal
                     const target = terminal || storage;
                     for(const res in creep.store) {
                         creep.transfer(target, res);
                     }
                 }
            }
        } 
    }  
};  

function findClosestTarget(creep, targets) {  
    let closest = targets[0];  
    let minDistance = creep.pos.getRangeTo(closest);  
    for (let i = 1; i < targets.length; i++) {  
        let distance = creep.pos.getRangeTo(targets[i]);  
        if (distance < minDistance) {  
            closest = targets[i];  
            minDistance = distance;  
        }  
    }  
    return closest;  
} 
export default rolethinker;
